Benzon Carlitos Salazar

Monoalphabetic Cipher Analysis


        For the analysis of the ciphertext, letter frequency analysis was the main method used. The Monoalphabetic.java program counts letter frequencies of single letters, and then manual analysis of the most common two- and three-letters were done to find the key. Basically, once the letter frequencies were found, I substituted the top 5 most common ones on a section of the ciphertext, because it was easier to validate a smaller section first rather than trying to write a program right away due to the large size of the plaintext. First, the top 5 most common letters in the ciphertext were K, E, U, G, V. By doing this, it showed me that the possible key structure for encryption of the first 5 letters of the alphabet were E, T, A, O, I. For the sake of simplicity, let E(“K”) = E be an encryption of K to E. So then, after substituting E for K, T for E, etc., I was able to find the patterns in the two- and three-letter words. Naturally after doing this, I moved on to figuring out the most common digraphs. According to letterfrequency.org, the top 5 most common digraphs were th, he, an, in, er. Because of this, I was able to find words like, the, which also suggested in the beginning that H was mapped to H. And by following this hunch, it made the decryption process a little bit easier.
        Anyway, starting out with digraphs was not as helpful as i thought, so I moved on to the most common two-letter words instead, and came back to the digraphs later on. The most common two-letter words are an, as, at, it, to. Because of this, I was able to map U to A confidently, which gave me words like a and at. After substituting G and V to O and I, respectively, I was able to find more words like of, on and or by using my knowledge of the English grammar. After doing more of this substitution and looking for more common digraphs and two-letter words, I eventually moved on to the most common tri-graphs and three-letter words. Again, I worked with the top 5 most common frequencies of both types of words, it turns out that the top 5 common tri-graphs are the, and, tha, ent, ion, and for three-letter words, the, and, for, are, but. Because of this, I was able to expand my possible encryption key structure to include E(“P”) = N and E(“I”) = V. I was able to completely find all the three-letter words in the section I was trying to decrypt. 
        Then, once all the three-letter words and tri-graphs were decrypted, I moved on to the most common four-letter words. By doing so, I was able to find words like that, with, have, this will. And due to previous decryptions using two- and three-letter words, I was able to find more words like your, from, and they. This process was the easiest one to do since a lot of the words were already figured out by previous techniques. This process was also helpful in figuring out longer words due to the fact that a lot of the six- and seven-letter words were easier to decrypt based on the context of the sentence, words like “replied”, because the letter characters before it were an open and closed quotation marks and the words after it were either a name of a person, or were pronouns like “him” or “her”. So it made sense that the whole sentence was “‘...’ replied him”. 
        After recursively going through the ciphertext, I was able to find the structure for the encryption key to be UIOYKLXHVBSFWJGNRDPECZMATQ. But since this was for an encryption key, I had to sort the encryption alphabet in ascending order to find its reciprocal alphabet and found the structure for the decryption key to be XJURTLOHBNEFWPCSZQKYAIMGDV. Then finally, I was able to decrypt the whole plaintext using the decrypt() method of the Monoalphabetic.java program and found that the ciphertext was The Scarlet Letter by Nathanial Hawthorne, the eBook version.